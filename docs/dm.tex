\documentclass{article}

\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[a4paper,colorlinks,linkcolor=darkgray,citecolor=red,urlcolor=blue]{hyperref}

\usepackage{tikz}
\usetikzlibrary{patterns} % pour hachures les figures

\title{Algorithmique et programmation parallèle : DM}

\newcommand{\X}[1]{{X}^{ #1 }}

\author{William \textsc{AUFORT} et Raphaël \textsc{Charrondière}}

\date{7 Décembre 2014}

\begin{document}
\maketitle

\section*{Question 1}

Pour calculer $\X{t+1}$ à partir de $\X{t}$ il faut appliquer la fonction $\delta$ à tous les éléments de $\X{t}$, soit $N^2$ fois.
Donc, pour calculer $\X{t}$ à partir de $\X{0}$, il faut répéter cette opération $t$ fois, ce qui donne $t N^2$ applications de la fonction $\delta$ nécessaires.

\section*{Question 2}

Nous donnons ici l'implémentation de l'automate cellulaire de la partie 3, et non pas l'implémentation de l'automate général (où les neuf voisins sont nécessaires pour la mise à jour). On expliquera néanmoins les différences après la description de l'algorithme. \\

Soient $p^2$ le nombre de processus disponibles, N la dimension de la grille. On suppose que $p$ divise $n$.
L'idée est de donner à chaque processus de la grille un bloc de $\left( \frac{N}{p} \right) ^2$ éléments selon la même topologie que celle de la grille de processus. \\

Considérons un processus $P_i$. 
Pour effectuer un calcul $\delta(x_{i,j})$, on a besoin en plus de $x_{i-1,j}$, $x_{i+1,j}$, $x_{i,j-1}$ et $x_{i,j+1}$.
On peut calculer l'image des éléments de $P_i$ qui ne sont pas à la frontière (les éléments en rouge sur la figure \ref{datas}), $P_i$ n'a besoin que de valeurs qui lui sont connues.
Les éléments à la frontière nécessite une ou deux valeurs dont disposent les processus voisins de $P_i$ sur la grille (les éléments en bleu sur la figure \ref{datas}).

\begin{figure}[!h]
  \centering
	\begin{tikzpicture}[scale = 0.5]
	  \draw[very thin, gray] (0,0) grid (8,8);
	  \fill[pattern = north east lines, pattern color = red] (2,2) -- (6,2) -- (6,6) -- (2,6) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (0,1) -- (0,7) -- (1,7) -- (1,1) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (1,7) -- (1,8) -- (7,8) -- (7,7) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (7,1) -- (7,7) -- (8,7) -- (8,1) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (1,0) -- (1,1) -- (7,1) -- (7,0) -- cycle;
	  \draw[very thick] (1,0) -- (1,8); \draw[very thick, dashed] (1,-1) -- (1,0); \draw[very thick, dashed] (1,8) -- (1,9);
	  \draw[very thick] (0,1) -- (8,1); \draw[very thick, dashed] (-1,1) -- (0,1); \draw[very thick, dashed] (8,1) -- (9,1);
	  \draw[very thick] (7,0) -- (7,8); \draw[very thick, dashed] (7,-1) -- (7,0); \draw[very thick, dashed] (7,8) -- (7,9);
	  \draw[very thick] (0,7) -- (8,7); \draw[very thick, dashed] (-1,7) -- (0,7); \draw[very thick, dashed] (8,7) -- (9,7);
      
	\end{tikzpicture}
  \caption{Schéma des données d'un processeur}
  \label{datas}
\end{figure}

Chaque processus $P_i$ va donc recevoir deux lignes (provenant de ses voisins horizontaux) et deux colonnes (provenant de ses voisins verticaux).
Et donc chaque $P_i$ doit également envoyer ces lignes et ces colonnes dont ont besoin les processus voisins, qui correspondent exactement aux éléments de la frontière.

Il est intéressant de remarquer que ces envois et réceptions peuvent être fait en parallèle, mais également pendant les calculs pour les éléments qui ne sont pas sur la frontière.

\section*{Question 3}

L'algorithme final est donc le suivant :

% TODO : Algorithme pour P_i
	

\end{document}
