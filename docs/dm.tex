\documentclass{article}

\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage[a4paper,colorlinks,linkcolor=darkgray,citecolor=red,urlcolor=blue]{hyperref}

\usepackage{tikz}
\usetikzlibrary{patterns} % pour hachures les figures

\usepackage[]{algorithm2e}

\title{Algorithmique et programmation parallèle : DM}

\newcommand{\X}[1]{{X}^{ #1 }}

\author{William \textsc{AUFORT} et Raphaël \textsc{Charrondière}}

\date{7 Décembre 2014}

\begin{document}
\maketitle

\section{Automate cellulaire}

\underline{Note :} Dans toute cette partie, on note $p^2$ le nombre de processeurs, $N$ la taille de la grille (qui contient donc $N^2$ éléments).
On supposera comme à l'habitude que $p$ divise $N$.

\subsection*{Question 1}

Pour calculer $\X{t+1}$ à partir de $\X{t}$ il faut appliquer la fonction $\delta$ à tous les éléments de $\X{t}$, soit $N^2$ fois.
Donc, pour calculer $\X{t}$ à partir de $\X{0}$, il faut répéter cette opération $t$ fois, ce qui donne $t N^2$ applications de la fonction $\delta$ nécessaires.

\subsection*{Question 2}

Nous donnons ici l'implémentation de l'automate cellulaire de la partie 3, et non pas l'implémentation de l'automate général (où les neuf voisins sont nécessaires pour la mise à jour). Nous expliquerons les différences après la description de l'algorithme. \\

L'idée est de disposer les processus selon une grille. processus Chaque dispose d'un bloc de $\left( \frac{N}{p} \right) ^2$ éléments.\\

Considérons un processus $P$. Celui-ci dispose des données $(\widehat{x_{i,j}})$.
Pour effectuer un calcul $\delta(\widehat{x_{i,j}})$, P a besoin en plus de $\widehat{x_{i-1,j}}$, $\widehat{x_{i+1,j}}$, $\widehat{x_{i,j-1}}$ et $\widehat{x_{i,j+1}}$.
On peut calculer l'image des éléments de $P_i$ qui ne sont pas à la frontière (les éléments en rouge sur la figure \ref{datas}), $P_i$ n'a besoin que de valeurs qui lui sont connues.
Les éléments à la frontière nécessitent quant à eux une ou deux valeurs dont disposent les processus voisins de $P_i$ sur la grille (les éléments en bleu sur la figure \ref{datas}) pour pouvoir être mis à jour.

\begin{figure}[!h]
  \centering
	\begin{tikzpicture}[scale = 0.5]
	  \draw[very thin, gray] (0,0) grid (8,8);
	  \fill[pattern = north east lines, pattern color = red] (2,2) -- (6,2) -- (6,6) -- (2,6) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (0,1) -- (0,7) -- (1,7) -- (1,1) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (1,7) -- (1,8) -- (7,8) -- (7,7) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (7,1) -- (7,7) -- (8,7) -- (8,1) -- cycle;
	  \fill[pattern = north east lines, pattern color = blue] (1,0) -- (1,1) -- (7,1) -- (7,0) -- cycle;
	  \draw[very thick] (1,0) -- (1,8); \draw[very thick, dashed] (1,-1) -- (1,0); \draw[very thick, dashed] (1,8) -- (1,9);
	  \draw[very thick] (0,1) -- (8,1); \draw[very thick, dashed] (-1,1) -- (0,1); \draw[very thick, dashed] (8,1) -- (9,1);
	  \draw[very thick] (7,0) -- (7,8); \draw[very thick, dashed] (7,-1) -- (7,0); \draw[very thick, dashed] (7,8) -- (7,9);
	  \draw[very thick] (0,7) -- (8,7); \draw[very thick, dashed] (-1,7) -- (0,7); \draw[very thick, dashed] (8,7) -- (9,7);
	\end{tikzpicture}
  \caption{Schéma des données d'un processeur. Les données en rouge peuvent être mises à jour par le processus, alors que les autres nécessitent les données en bleu des processus voisins.}
  \label{datas}
\end{figure}

Chaque processus va donc recevoir deux lignes (provenant de ses voisins horizontaux) et deux colonnes (provenant de ses voisins verticaux).
Chaque processus doit donc également envoyer les lignes (respectivement les colonnes) supérieures et inférieures dont ont besoin les processus voisins horizontaux (repectivement verticaux), qui correspondent exactement aux éléments de la frontière.

Il est intéressant de remarquer que ces envois et réceptions peuvent être fait en parallèle, mais également pendant les calculs pour les éléments qui ne sont pas sur la frontière.

\paragraph{Cas général}

Dans le cas général, il y a une petite subtilité. Pour pouvoir mettre à jour les quatres éléments aux "coins", il faut disposer également d'une donnée de chaque processus voisin selon la diagonale. Mais cette donnée ne peut pas être transmise directement, à cause de la topologie de grille. Par contre, cette valeur est contenue dans une colonne échangée à un processus voisin de $P$ lors de la première étape (voir figure \ref{datas2}), ce qui permet de demander directement la valeur aux processus voisins.

\begin{figure}[!h]
  \centering
	\begin{tikzpicture}[scale = 0.5]
	  \draw[very thin, gray] (0,0) grid (8,8);
	  \fill[pattern = north east lines, pattern color = red] (7,7) -- (7,8) -- (8,8) -- (8,7) -- cycle;
	  \draw[thick,->] (7.5,7.5) -- (6.5,7.5);
	  \draw[thick,->] (6.5,7.5) -- (6.5,6.5);
	  \draw (4,9) node[scale=1.5]{$P_1$};
	  \draw (4,4) node[fill=white,scale=1.5]{$P_2$};
	  \draw (9,9) node[scale=1.5]{$P_3$};
	  \draw[very thick] (1,0) -- (1,8); \draw[very thick, dashed] (1,-1) -- (1,0); \draw[very thick, dashed] (1,8) -- (1,9);
	  \draw[very thick] (0,1) -- (8,1); \draw[very thick, dashed] (-1,1) -- (0,1); \draw[very thick, dashed] (8,1) -- (9,1);
	  \draw[very thick] (7,0) -- (7,8); \draw[very thick, dashed] (7,-1) -- (7,0); \draw[very thick, dashed] (7,8) -- (7,9);
	  \draw[very thick] (0,7) -- (8,7); \draw[very thick, dashed] (-1,7) -- (0,7); \draw[very thick, dashed] (8,7) -- (9,7);
	\end{tikzpicture}
  \caption{Transmission des 4 données manquantes. La donnée (en rouge) qui intéresse $P_2$ est transmise à $P_1$ lors de la première phase où $P_3$ transmet sa colonne. $P_2$ peut donc demander cette données directement à $P_1$.}
  \label{datas2}
\end{figure}

\subsection*{Question 3}

L'algorithme final est présenté ci-dessous :

% TODO : Algorithme pour P_i

\begin{algorithm}[H]
  \KwData{Une matrice $X$}
  \KwResult{La matrice $Y = \delta^{+}\left(X\right)$}
  p $\longleftarrow \sqrt{NbProcs()}$\;
  q $\longleftarrow$ MyNum()\;
  N $\longleftarrow$ SizeOfGrid()\;
  \For{i = 1 to ($\frac{N}{p}-2$)}{
	\For{j = 1 to ($\frac{N}{p}-2$)} {
	  Mettre à jour l'élément $\widehat{x_{i,j}}$ avec les données de $P_q$.
    }
  }
  // send(les deux lignes et les deux colonnes) \;
  // receive(les deux lignes et les deux colonnes) \;		
  \For{j = 0 to ($\frac{N}{p}-1$)}{
	Mettre à jour les elements $\widehat{x_{0,j}}$ et $\widehat{x_{N-1,j}}$ avec les données reçues\;
  }
  \For{i = 1 to ($\frac{N}{p}-2$)}{
	Mettre à jour les elements $\widehat{x_{i,0}}$ et $\widehat{x_{i,N-1}}$ avec les données reçues\;
  }
 \caption{L'algorithme de la question 3}
\end{algorithm}

\subsubsection*{Complexité}

Soit $\omega$ le temps nécessaire pour effectuer une mise à jour d'un élément $x_{i,j}$.
La première partie de l'algorithme (premières mises à jour, send et receive) prend un temps $max \left( (\frac{N}{p}-2)^2\omega, 4(L + (\frac{N}{p}-2)b) \right) $.

La seconde partie prend un temps $(\frac{2N}{p} + 2(\frac{N}{p}-2))\omega$ = $(\frac{4N}{p}-4)\omega$.

D'où une complexité temporelle finale : $T(N,p) = max \left( \left(\frac{N}{p}-2\right)^2\omega, 4\left(L + \left(\frac{(N-2)b}{p}\right) \right) \right)  + \left(\frac{4N}{p}-4 \right)\omega $.

\underline{Remarque :} Quand $N$ tend vers $+\infty$, $T(N,p) \underset{N \rightarrow +\infty}{\thicksim} \left(\frac{N}{p}-2\right)^2\omega \underset{N \rightarrow +\infty}{\thicksim} \frac{N^2\omega}{p^2}$. 

\subsubsection*{Adaptation sur une grille non torique}

Si on conserve avec exactitude le principe de l'algorithme, le seul problème consistera pour les processus en bordure de grille, lors des send/receive.
Concrètement, si on note cette fois $P_{i,j}$ les processeurs ($(i,j) \in \left\{ 0, \dots,p-1\right\}$), les processus $P_{0,i}$ ne peuvent pas envoyer leur ligne au processus $P_{p-1,i}$ (même chose de $P_{i,0}$ vers $P_{i,p-1}$).
Une solution pourrait être de les faire passer à travers toute une ligne (respectivement toute une colonne), ce qui nécessiterai un temps $(p-1)(L + \frac{(n-2)b}{p})$ supplémentaire pour chaque envoi, soit un temps total de $4p(p-1)(L + \frac{(n-2)b}{p})$
% TODO : Toutefois ces envois peuvent peut-être se faire en parallèle d'autres calculs... Il faudrait réfléchir à cela.

\subsubsection*{Et sur une topologie en anneau ?}

Sur une topologie en anneau la situation se complique... Si on numérote les processus de gauche à droite et de haut en bas, les transmissions verticales devront passer par exactement $p-1$ processus intermédiaires avant d'arriver à destination. Toutefois, on peut réutiliser la technique vue en cours pour le broadcast généralisé (où toutes les données transitent en même temps) pour les deux transmissions verticales que doit accomplir chaque processus.

\section{Average automata}

\subsection*{Question 4} 

Voir le fichier \texttt{average.c}.

\subsection*{Question 5}

Pour prouver que $\delta^+$ est linéaire, il suffit de montrer que pour tous $(i,j) \in \mathbb{N}$, pour tout $k \in \mathbb{R}$, 
$$(\delta^+(X+Y))_{i,j} = (\delta^+(X))_{i,j} + (\delta^+(Y))_{i,j} \quad \text{et} \quad (\delta^+(kX))_{i,j} = k(\delta^+(X))_{i,j}$$.

Sachant que $(\delta^+(X))_{i,j} = (1-p)x_{i,j} + \frac{p}{4} \left(x_{i,j+1} + x_{i,j-1} + x_{i+1,j} + x_{i-1,j}\right)$, le résultat est immédiat.

L'idée est que si on a une fonction linéaire, on peut la représenter par une matrice, mais celle-ci sera de taille $N^4$.

Quelques éléments d'explications. Ici on identifie $\mathcal{M}_N(\mathbb{R})$ et $\mathbb{R}^{N^2}$ pour représenter la matrice $X$. \\

$ \begin{pmatrix} a & b & c \\ d & e & f \\ g & h & i \end{pmatrix} \longrightarrow \left( \begin{array}{c} a \\ b \\ c \\ d \\ e \\ f \\ g \\ h \\ i \end{array} \right)$
On peut alors voir la fonction $\delta^+$ sous forme matricielle, comme l'illustre la figure suivante. % TODO Ref !

$\left( \begin{array}{c} x_1 \\ x_2 \end{array} \right] = \begin{bmatrix} A & B \\ C & D \end{bmatrix} \times \left[ \begin{array}{c} y_1 \\ y_2 \end{array} \right]$


\subsection*{Question 10}



\end{document}
